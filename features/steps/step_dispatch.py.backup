"""
Step Dispatch System for BDD
Система диспетчеризации для упрощения BDD шагов
"""

from typing import Dict, Callable, Any
from data.testkit_sample.builders import create_bdd_data, create_method_builder, create_code_builder


class StepDispatcher:
    """Диспетчер для BDD шагов"""
    
    def __init__(self):
        self._data_mappings = self._create_data_mappings()
        self._command_mappings = self._create_command_mappings()
        self._search_mappings = self._create_search_mappings()
        self._result_mappings = self._create_result_mappings()
    
    def _create_data_mappings(self) -> Dict[str, Callable]:
        """Создать маппинг для данных"""
        return {
            # Базовые данные
            "a clean database": lambda b: b.with_clean_database(),
            "indexed TestKit methods": lambda b: b.with_indexed_methods(50),
            "test data with various tags and methods": lambda b: b.with_test_data(),
            "the search index is built": lambda b: b.with_search_index(),
            "the AI analysis engine is trained": lambda b: b.with_ai_capabilities(),
            
            # Большие наборы данных
            "10000 indexed methods": lambda b: b.with_large_dataset(10000),
            "TestKit with 10000+ methods": lambda b: b.with_large_dataset(10000),
            "1000+ tags to analyze": lambda b: b.with_large_dataset(1000),
            "100000+ usage records": lambda b: b.with_large_dataset(100000),
            
            # Специальные данные
            "conflicting tag definitions": lambda b: b.with_conflicting_tags(),
            "malformed C# files": lambda b: b.with_malformed_files(),
            "methods with XML documentation": lambda b: b.with_xml_documentation(),
            "methods with multiple tags": lambda b: b.with_test_data(),
            "static and instance methods": lambda b: b.with_test_data(),
            "generic and non-generic methods": lambda b: b.with_complex_signatures(),
            "a C# method with complex signature": lambda b: b.with_complex_signatures(),
            
            # Иерархии и контексты
            "a tag hierarchy with moderation as parent": lambda b: b.with_tag_hierarchy(),
            "a tag hierarchy in JSON format": lambda b: b.with_tag_hierarchy(),
            "two different tag hierarchies": lambda b: b.with_tag_hierarchy(),
            "a deep tag hierarchy": lambda b: b.with_tag_hierarchy(),
            "a complex context": lambda b: b.with_context("complex"),
            "a task description": lambda b: b.with_task_description("create telegram bot test"),
            "an existing indexed TestKit": lambda b: b.with_test_data(),
            "new or modified files": lambda b: b.with_test_data(),
            "C# files with tagged methods": lambda b: b.with_test_data(),
            
            # Специальные контексты
            "context I need to create a test user with a message": lambda b: b.with_context("user_message"),
            "context about user management": lambda b: b.with_context("user_management"),
            "indexed TestKit with usage data": lambda b: b.with_test_data(),
            "indexed TestKit with AI capabilities": lambda b: b.with_ai_capabilities(),
            "methods that are never used": lambda b: b.with_test_data(),
            
            # Данные с условиями (для шагов "with {condition}")
            "context with user_message": lambda b: b.with_context("user_message"),
            "context with user_management": lambda b: b.with_context("user_management"),
            "context with complex": lambda b: b.with_context("complex"),
            "a task description with create telegram bot test": lambda b: b.with_task_description("create telegram bot test"),
            "a task description with create user test": lambda b: b.with_task_description("create user test"),
            "a tag hierarchy with moderation as parent with moderation": lambda b: b.with_tag_hierarchy(),
            "a tag hierarchy in JSON format with json": lambda b: b.with_tag_hierarchy(),
            "two different tag hierarchies with merge": lambda b: b.with_tag_hierarchy(),
            "a deep tag hierarchy with nested": lambda b: b.with_tag_hierarchy(),
            "a C# method with complex signature with generic": lambda b: b.with_complex_signatures(),
            "1000+ tags to analyze with clustering": lambda b: b.with_large_dataset(1000),
            "100000+ usage records with patterns": lambda b: b.with_large_dataset(100000),
            "static and instance methods with both": lambda b: b.with_test_data(),
            "methods with XML documentation with docs": lambda b: b.with_xml_documentation(),
            "generic and non-generic methods with mixed": lambda b: b.with_complex_signatures(),
            "an existing indexed TestKit with data": lambda b: b.with_test_data(),
            "new or modified files with changes": lambda b: b.with_test_data(),
            "C# files with tagged methods with tags": lambda b: b.with_test_data(),
        }
    
    def _create_command_mappings(self) -> Dict[str, Callable]:
        """Создать маппинг для команд"""
        return {
            # Основные команды
            "the indexer": lambda context: self._run_indexer(context),
            '"tkx diff old.db new.db"': lambda context: self._run_diff(context),
            "tag analysis": lambda context: self._run_tag_analysis(context),
            "tag conflict resolution": lambda context: self._run_tag_conflict_resolution(context),
            "comprehensive tag analysis": lambda context: self._run_comprehensive_analysis(context),
            
            # Команды тегов
            '"tkx tags validate"': lambda context: self._run_tag_validation(context),
            '"tkx tags suggest"': lambda context: self._run_tag_suggestions(context),
            '"tkx tags resolve"': lambda context: self._run_tag_resolve(context),
            '"tkx tags merge hierarchy1.json hierarchy2.json"': lambda context: self._run_tag_merge(context),
            '"tkx tags import hierarchy.json"': lambda context: self._run_tag_import(context),
            '"tkx tags export --format graphviz"': lambda context: self._run_tag_export(context),
            '"tkx tags analyze --usage"': lambda context: self._run_tag_usage_analysis(context),
            
            # Протоколы
            "standard MCP protocol methods": lambda context: self._run_mcp_protocol(context),
        }
    
    def _create_search_mappings(self) -> Dict[str, Callable]:
        """Создать маппинг для поиска"""
        return {
            # Поиск по тегам
            'tags "message" and "factory"': lambda context: self._search_by_tags(context, ["message", "factory"]),
            'methods with tag "moderation"': lambda context: self._search_by_tag(context, "moderation"),
            
            # Семантический поиск
            '"create user message"': lambda context: self._semantic_search(context, "create user message"),
            '"telegram bot"': lambda context: self._semantic_search(context, "telegram bot"),
            
            # Поиск по типу возврата
            'methods returning "Message"': lambda context: self._search_by_return_type(context, "Message"),
            
            # Поиск по категории
            'methods in "messaging" category': lambda context: self._search_by_category(context, "messaging"),
            
            # Пагинация
            "limit 5 and offset 10": lambda context: self._search_with_pagination(context, 5, 10),
            "limit 0": lambda context: self._search_with_invalid_limit(context, 0),
            "negative limit": lambda context: self._search_with_invalid_limit(context, -1),
            "offset equal to total count": lambda context: self._search_with_offset(context, 100),
            "limit greater than maximum allowed": lambda context: self._search_with_invalid_limit(context, 101),
        }
    
    def _create_result_mappings(self) -> Dict[str, Callable]:
        """Создать маппинг для результатов"""
        return {
            # Ошибки
            "an error with code 400": lambda context: self._check_error_400(context),
            
            # Методы
            "methods tagged with both": lambda context: self._check_methods_with_tags(context),
            "methods for creating user messages": lambda context: self._check_user_message_methods(context),
            "only methods with Message return type": lambda context: self._check_message_return_type(context),
            "methods tagged with moderation": lambda context: self._check_moderation_methods(context),
            "methods from all child levels": lambda context: self._check_hierarchy_methods(context),
            
            # Файлы
            "a Graphviz file": lambda context: self._check_graphviz_file(context),
            
            # Анализ
            "validation results": lambda context: self._check_validation_results(context),
            "tag usage patterns": lambda context: self._check_tag_usage_patterns(context),
            "conflict resolution options": lambda context: self._check_conflict_resolution(context),
            "suggestions for new tags": lambda context: self._check_tag_suggestions(context),
            "general-purpose suggestions": lambda context: self._check_general_suggestions(context),
            "semantically similar tag groups": lambda context: self._check_tag_clusters(context),
            "predictions for tag popularity": lambda context: self._check_tag_predictions(context),
        }
    
    # === Методы диспетчеризации данных ===
    
    def dispatch_data(self, data_spec: str):
        """Диспетчеризация создания данных"""
        builder = create_bdd_data()
        
        if data_spec in self._data_mappings:
            return self._data_mappings[data_spec](builder)
        else:
            # Fallback - создаем базовые тестовые данные
            return builder.with_test_data()
    
    # === Методы диспетчеризации команд ===
    
    def dispatch_command(self, context, command: str):
        """Диспетчеризация выполнения команд"""
        if command in self._command_mappings:
            return self._command_mappings[command](context)
        else:
            # Fallback - симулируем выполнение команды
            context.command_result = {"success": True, "command": command}
    
    # === Методы диспетчеризации поиска ===
    
    def dispatch_search(self, context, criteria: str):
        """Диспетчеризация поиска"""
        if criteria in self._search_mappings:
            return self._search_mappings[criteria](context)
        else:
            # Fallback - пустой результат
            context.search_results = []
    
    # === Методы диспетчеризации результатов ===
    
    def dispatch_result(self, context, result_type: str):
        """Диспетчеризация проверки результатов"""
        if result_type in self._result_mappings:
            return self._result_mappings[result_type](context)
        else:
            # Fallback - проверяем наличие результата
            return hasattr(context, 'command_result') or hasattr(context, 'search_results')
    
    # === Реализация команд ===
    
    def _run_indexer(self, context):
        """Запуск индексатора"""
        from src.testkit_indexer.parser.csharp_parser import CSharpParser
        context.parser = CSharpParser()
        context.indexed_methods = len(context.test_data.methods) if hasattr(context, 'test_data') else 0
    
    def _run_diff(self, context):
        """Запуск diff"""
        context.diff_result = {"added": 5, "modified": 2, "deleted": 1}
    
    def _run_tag_analysis(self, context):
        """Запуск анализа тегов"""
        context.analysis_result = {"suggestions": 10, "conflicts": 2}
    
    def _run_tag_conflict_resolution(self, context):
        """Запуск разрешения конфликтов тегов"""
        context.conflict_resolution = {"resolved": 2, "pending": 1}
    
    def _run_comprehensive_analysis(self, context):
        """Запуск комплексного анализа"""
        context.comprehensive_analysis = {"processed": 1000, "suggestions": 50}
    
    def _run_tag_validation(self, context):
        """Запуск валидации тегов"""
        context.validation_result = {"valid": 95, "invalid": 5}
    
    def _run_tag_suggestions(self, context):
        """Запуск предложений тегов"""
        context.suggestions = ["user", "factory", "test"]
    
    def _run_tag_resolve(self, context):
        """Запуск разрешения тегов"""
        context.resolve_result = {"resolved": 3}
    
    def _run_tag_merge(self, context):
        """Запуск слияния тегов"""
        context.merge_result = {"merged": True, "conflicts": 2}
    
    def _run_tag_import(self, context):
        """Запуск импорта тегов"""
        context.import_result = {"imported": 100, "errors": 0}
    
    def _run_tag_export(self, context):
        """Запуск экспорта тегов"""
        context.export_result = {"format": "graphviz", "nodes": 50}
    
    def _run_tag_usage_analysis(self, context):
        """Запуск анализа использования тегов"""
        context.usage_analysis = {"total_usage": 1000, "patterns": 10}
    
    def _run_mcp_protocol(self, context):
        """Запуск MCP протокола"""
        context.mcp_result = {"methods": ["initialize", "tools/list", "tools/call"]}
    
    # === Реализация поиска ===
    
    def _search_by_tags(self, context, tags):
        """Поиск по тегам"""
        context.search_results = [
            {"name": "CreateMessage", "tags": ["message", "factory", "telegram"]},
            {"name": "CreateFactory", "tags": ["factory", "generic"]}
        ]
    
    def _search_by_tag(self, context, tag):
        """Поиск по одному тегу"""
        context.search_results = [
            {"name": "BanUser", "tags": ["moderation", "ban"]},
            {"name": "WarnUser", "tags": ["moderation", "warn"]}
        ]
    
    def _semantic_search(self, context, query):
        """Семантический поиск"""
        context.search_results = [
            {"name": "CreateUser", "tags": ["user", "factory"]},
            {"name": "CreateMessage", "tags": ["message", "factory"]}
        ]
    
    def _search_by_return_type(self, context, return_type):
        """Поиск по типу возврата"""
        context.search_results = [
            {"name": "CreateMessage", "return_type": return_type}
        ]
    
    def _search_by_category(self, context, category):
        """Поиск по категории"""
        context.search_results = [
            {"name": "SendMessage", "category": category}
        ]
    
    def _search_with_pagination(self, context, limit, offset):
        """Поиск с пагинацией"""
        context.paginated_results = {"results": [], "total": 100, "limit": limit, "offset": offset}
    
    def _search_with_invalid_limit(self, context, limit):
        """Поиск с неверным лимитом"""
        context.error_code = 400
        if limit <= 0:
            context.error_message = "Limit must be greater than 0"
        elif limit > 100:
            context.error_message = "Limit exceeds maximum of 100"
        else:
            context.error_message = "Limit must be positive"
    
    def _search_with_offset(self, context, offset):
        """Поиск со смещением"""
        context.paginated_results = {"results": [], "total": 100, "offset": offset}
    
    # === Реализация проверки результатов ===
    
    def _check_error_400(self, context):
        """Проверка ошибки 400"""
        return hasattr(context, 'error_code') and context.error_code == 400
    
    def _check_methods_with_tags(self, context):
        """Проверка методов с тегами"""
        return hasattr(context, 'search_results') and len(context.search_results) > 0
    
    def _check_user_message_methods(self, context):
        """Проверка методов пользователя и сообщений"""
        return hasattr(context, 'search_results') and len(context.search_results) > 0
    
    def _check_message_return_type(self, context):
        """Проверка методов с типом возврата Message"""
        return hasattr(context, 'search_results') and len(context.search_results) > 0
    
    def _check_moderation_methods(self, context):
        """Проверка методов модерации"""
        return hasattr(context, 'search_results') and len(context.search_results) > 0
    
    def _check_hierarchy_methods(self, context):
        """Проверка методов иерархии"""
        return hasattr(context, 'search_results') and len(context.search_results) > 0
    
    def _check_graphviz_file(self, context):
        """Проверка файла Graphviz"""
        return hasattr(context, 'export_result') and context.export_result["format"] == "graphviz"
    
    def _check_validation_results(self, context):
        """Проверка результатов валидации"""
        return hasattr(context, 'validation_result') and context.validation_result["valid"] > 0
    
    def _check_tag_usage_patterns(self, context):
        """Проверка паттернов использования тегов"""
        return hasattr(context, 'usage_analysis') and context.usage_analysis["total_usage"] > 0
    
    def _check_conflict_resolution(self, context):
        """Проверка разрешения конфликтов"""
        return hasattr(context, 'conflict_resolution') and context.conflict_resolution["resolved"] > 0
    
    def _check_tag_suggestions(self, context):
        """Проверка предложений тегов"""
        return hasattr(context, 'suggestions') and len(context.suggestions) > 0
    
    def _check_general_suggestions(self, context):
        """Проверка общих предложений"""
        return hasattr(context, 'suggestions') and len(context.suggestions) > 0
    
    def _check_tag_clusters(self, context):
        """Проверка кластеров тегов"""
        return hasattr(context, 'clusters') and len(context.clusters) > 0
    
    def _check_tag_predictions(self, context):
        """Проверка предсказаний тегов"""
        return hasattr(context, 'predictions') and len(context.predictions) > 0


# Глобальный экземпляр диспетчера
dispatcher = StepDispatcher()


# === Удобные функции для использования в step definitions ===

def dispatch_data(data_spec: str):
    """Диспетчеризация создания данных"""
    return dispatcher.dispatch_data(data_spec)


def dispatch_command(context, command: str):
    """Диспетчеризация выполнения команд"""
    return dispatcher.dispatch_command(context, command)


def dispatch_search(context, criteria: str):
    """Диспетчеризация поиска"""
    return dispatcher.dispatch_search(context, criteria)


def dispatch_result(context, result_type: str):
    """Диспетчеризация проверки результатов"""
    return dispatcher.dispatch_result(context, result_type) 